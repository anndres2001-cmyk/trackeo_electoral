import pandas as pd               # manejo de Tablas (DataFrames). Matemáticamente son Matrices.
import numpy as np                # cálculo numérico, maneja vectores y matrices rápidas.
import matplotlib.pyplot as plt   # librería base para graficar (Ejes, Figuras).
import matplotlib.ticker as mtick # herramienta para formatear ejes (ej: poner el signo %).
import os                         # "Operating System". Permite crear carpetas y guardar archivos en tu PC.

# Librerías de Inteligencia Artificial (Scikit-Learn)
from sklearn.experimental import enable_iterative_imputer  # Habilita el MICE (aún es experimental en sklearn).
from sklearn.impute import IterativeImputer                # El algoritmo MICE para llenar datos faltantes.
from sklearn.linear_model import LinearRegression          # Usado por MICE para adivinar números.
from sklearn.linear_model import LogisticRegression        # Usado para predecir Voto (Sí/No).

### SELECCIONAR CANDIDATO

def listar_y_elegir(lista_opciones, mensaje="Seleccioná una opción"): #de forma numerica elegimos al candidato a traves de la funcion "listar_y_elegir". recibe una lista de opciones y un mensaje opcional que se muestra como título del menú.
    print(f"\n--- {mensaje} ---")                  # Imprime el título del menú.
    for i, op in enumerate(lista_opciones):       # Recorre la "lista_opciones" con enumarate(), indexando el conjunto de opciones (0, 1, 2...).
        if isinstance(op, tuple):                 # wi la opción es una tupla
            print(f"[{i}] {op[0]}")               # ... muestra solo el primer nombre.
        else:
            print(f"[{i}] {op}")                  # sino, muestra la opción tal cual.
    
    while True:                                   # bucle infinito: no sale hasta que el usuario escriba bien (return)
        try:
            inp = input("Ingrese el número: ")    # pide el dato al teclado.
            idx = int(inp)                        # Intenta convertir ese string a numero entero
            
            # Lógica Booleana: Verifica si el número está dentro del rango de la lista.
            if 0 <= idx < len(lista_opciones):    #el indice dentro de a logica
                val = lista_opciones[idx]         # recuperando el objeto real de la lista.
                return val[0] if isinstance(val, tuple) else val # Devuelve el valor limpio.
            
            print("EROR.")      # Si el número es muy alto o negativo.
        except ValueError:
            print("ERROR. Escribime un numero válido.") # Si escribió letras en vez de números.

# LIMPIEZA
def preparar_base(df_raw): #vamos a usar el CSV como base cruda #vamos a normalizar los nombres de las columnas #eliminamos filas que no sirvan (sin fecha o voto)
    df = df_raw.copy() # creamos una copia en memoria para no romper el original df_raw.copy()
    df.columns = (df.columns.str.strip().str.lower() # .str.strip(): Saca espacios a los costados. # .str.lower(): Pasa todo a minúsculas.
                  .str.replace(r"[^a-z0-9_ ]", "", regex=True)
                  .str.replace(r"\s+", "_", regex=True)) # eeemplaza espacios internos por guion bajo. # regex r"[^a-z0-9_ ]": "Si NO es letra, número o guion bajo, bórralo".
    
    cols = df.columns                                     # Guarda la lista de nombres limpios.
    print("\nDIAGNÓSTICO DE COLUMNAS")

    try:                                                                                                   # con "try" niciamos un bloque que atrapará errores si falta alguna columna.
        c_fecha = [c for c in cols if "fecha" in c or "date" in c or "time" in c][0]                       # busca columna que tenga "fecha", "date" o "time". Toma la primera [0].
        c_id = [c for c in cols if ("ident" in c or "id_" in c or "encuesta" in c) and "fecha" not in c][0] # usca ID: debe decir "id" o "encuesta" PERO NO "fecha" (Lógica: A y No B).
        c_estrato_list = [c for c in cols if "estrato" in c or "socio" in c]                                # busca Estrato: puede no existir, por eso chequeamos si la lista está vacía al final.
        c_estrato = c_estrato_list[0] if c_estrato_list else None                                           # busca posibles columnas de estrato; puede haber 0 o más.
        c_sexo = [c for c in cols if "sexo" in c or "genero" in c][0]                                         
        c_edad = [c for c in cols if "edad" in c or "anos" in c][0]
        c_educ = [c for c in cols if "educ" in c or "nivel" in c or "instruccion" in c][0]
        c_hogar = [c for c in cols if "integrantes" in c or "hogar" in c or "personas" in c][0]
        c_imagen = [c for c in cols if "imagen" in c][0]
        c_voto = [c for c in cols if "voto" in c and "anterior" not in c][0]                                  # en caso de voto elegimos que no sea "anterior"
        c_voto_ant = [c for c in cols if "anterior" in c][0]

        col_map = {                                                                                            #a las busquedas de nombres las pusimos dentro de un diccionario para poder integrarlas mejor y cambiarles el nombre
            c_fecha: "fecha", c_id: "encuesta", c_sexo: "sexo", c_edad: "edad",
            c_educ: "nivel_educativo", c_hogar: "integrantes_h", c_imagen: "imagen_candidato",
            c_voto: "voto", c_voto_ant: "voto_anterior"
        }
        if c_estrato: col_map[c_estrato] = "estrato" #solo renombra estrato si existe.

        print(f"Columnas identificadas")
    except IndexError:                                                                                         # Si alguna lista [c for c...] quedó vacía, [0] significa que da ERROR, por lo tanto, que imprima error
        raise ValueError("ERROR: faltan columnas obligatorias en el CSV.")

    df = df.rename(columns=col_map) # aplica los renombres definidos en col_map. ACA SE ESTANDARIZAN las variables para el resto del pipeline.
vars_txt = ["estrato", "sexo", "nivel_educativo", "voto", "voto_anterior"]                                  ## UNA VEZ las columnas esten limpias hay que limpiarlas, a las variables (string) cualuqier cosa reemplazamos por np.nan
    for col in vars_txt:                                                                                        ## Recorremos una por una todas esas columnas.
        if col in df.columns:                                                                                    ## verificamos que la columna exista realmente en el DataFrame.
            df[col] = df[col].astype(str).str.strip().str.lower().replace(["nan", "none", "null", "", " "], np.nan) ##las estandariza y al resto las vuelve NaN

    vars_num = ["edad", "integrantes_h", "imagen_candidato"]                                                      ## a las Variables numérica las forzamos a número. 'errors="coerce"' convierte errores en NaN (Vacío).
    for col in vars_num:                                                                                         ## Lista de columnas numéricas que pueden venir mal cargadas.
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    criticas = ["fecha", "encuesta", "integrantes_h", "imagen_candidato", "voto", "voto_anterior"]              # # Si falta fecha, voto o imagen, la encuesta no sirve. Se elimina la fila.
    criticas_reales = [c for c in criticas if c in df.columns]                                                  # Filtramos solo las que existen en "criticas" a "critical_reales"
    
    n_antes = len(df)                                                                                           ## guardamos las filas en una variable n_antes , antes de eliminarlas
    df = df.dropna(subset=criticas_reales)                                                                       # Drop NaN (Borrar Nulos). Elimina filas inservibles: sin fecha, sin voto, sin imagen, etc.
    print(f"Se eliminaron {n_antes - len(df)} filas por falta de datos")

    if "imagen_candidato" in df.columns: df["imagen_candidato"] = df["imagen_candidato"].clip(0, 100)            # si la imagen del candidato existe entonces las ajustamos a 0 o 100 si pasa alguna de las dos. Función Clip. f(x) = min(max(x, 0), 100).
    
    return df
def unificar_sexo(df):                                                                                          ## vamos a detectar las columnas de sexo y sus derivados: generando sexo_mas_unificado y sexo_fem_unificado
    df_out = df.copy() ## Busca todas las columnas que empiecen con 'sexo_'
    cols_sexo = [c for c in df_out.columns if c.startswith("sexo_")]                                       #buscamos todas las columnas que empiecen por sexo
    cols_fem = [c for c in cols_sexo if "fem" in c or "mujer" in c or c.endswith("_f")]                   #filtramos por palabras claves entre los "sexo"
    cols_masc = [c for c in cols_sexo if "masc" in c or "hombre" in c or c.endswith("_m")]

    if cols_fem:
        df_out["sexo_femenino_unificado"] = df_out[cols_fem].sum(axis=1).clip(0, 1)                 #si tenía sexo_fem=1 y sexo_mujer=0 → 1. si tenía errores tipo 1 y 1 → queda 2 → clip(0,1) lo baja a 1.
        df_out = df_out.drop(columns=cols_fem)                                                      # Borra las originales para no duplicar.
    if cols_masc:
        df_out["sexo_masculino_unificado"] = df_out[cols_masc].sum(axis=1).clip(0, 1)
        df_out = df_out.drop(columns=cols_masc)
    return df_out

def imputar_datos(df_limpio):                                                                       # ahora que tenemos las columnas vamos a IMPUTAR con MICE que utiiliza las relaciones matematicas entre variables para estimar los valores faltantes.
    df = df_limpio.copy()                                                                          ## hacemos una copia del DF
    cols_cat = [c for c in ["estrato", "sexo", "nivel_educativo"] if c in df.columns]               # Elegimos qué variables categóricas vamos a usar para ayudar a la predicción.
    if "voto" in df.columns: df = pd.get_dummies(df, columns=["voto"], dummy_na=False)               ## # BINARIZAMOS "voto" y "voto_anterior"(One-Hot Encoding) para que el modelo 'vea' a quién vota la gente. # y use eso para predecir su estrato/edad faltante.
    if "voto_anterior" in df.columns: df = pd.get_dummies(df, columns=["voto_anterior"], dummy_na=False)

# Binarizamos las demográficas faltantes
    df_encoded = pd.get_dummies(df, columns=cols_cat, dummy_na=False)
    
    # Algoritmo MICE:
    # Itera (repite) regresiones lineales.
    # Primero: rellena con el promedio.
    # Segundo: predice Edad usando (Voto + Estrato). Actualiza Edad.
    # Tercero: predice Estrato usando (Voto + Edad nueva).
    # ... Repite 20 veces (max_iter) hasta que los números se estabilizan (convergen).
    imputer = IterativeImputer(estimator=LinearRegression(), max_iter=20, random_state=42, min_value=0) # creamos el objeto MICE que imputará los valores faltantes usando regresiones lineales iteradas. 
    
    
    cols_si = [c for c in df_encoded.columns if c not in ["fecha", "encuesta"]]    # celeccionamos todas las columnas numéricas excepto los IDs y Fechas (que no tienen correlación matemática útil).
    if cols_si:
        try:    #Abre bloque seguro para ejecutar el imputador sin romper el programa si falla.
            df_encoded[cols_si] = imputer.fit_transform(df_encoded[cols_si])     ## ajusta regresiones internas y rellena todos los valores faltantes. El imputador devuelve una matriz numérica completa y la
            if "edad" in df_encoded.columns: df_encoded["edad"] = df_encoded["edad"].round().astype(int) # Si la columna “edad” existe luego del proceso entonces redondeo: La edad estimada puede ser 34.6 años -> pasamos a 35.
        except: 
            pass # si falla (ej: matriz vacía), devolvemos como estaba.
        
    return df_encoded

# Graficos

def graficar_estilo_premium(df, col_x, col_y=None, col_grupo=None, estilo=1):    # ahora GRAFICOS usando matplotlib. DF: tabla de graficos. col x/ col_y
    plt.style.use('seaborn-v0_8-whitegrid')                                      # configuramos estética (fondo blanco con grilla suave).
    
    if estilo == 1:                                                              # 1- vamos a dar la opcion de elegir el grafico: histograma
        variable = df[col_x]
        plt.figure(figsize=(8, 5))
        plt.hist(variable, bins=20, edgecolor="black", color="#69b3a2", alpha=0.8) # bins= divide el rango de datos en 20 cajones
        plt.title(f"Distribución de {col_x}", fontsize=14, fontweight='bold')
        plt.ylabel("Cantidad de Casos"); plt.xlabel(col_x)
        plt.tight_layout(); plt.show()

    elif estilo == 2 and col_y:                                                 # 2- scatter
        plt.figure(figsize=(8, 5))
        plt.scatter(df[col_x], df[col_y], alpha=0.5, color="#4c72b0")          # Plotea puntos (x, y) en el plano cartesiano.
        plt.title(f"Correlación: {col_x} vs {col_y}", fontsize=14, fontweight='bold')
        plt.xlabel(col_x); plt.ylabel(col_y)
        plt.tight_layout(); plt.show()

    elif estilo == 3 and col_y and col_grupo:
        grupos = df[col_grupo].unique()
        colores = plt.cm.tab10(np.linspace(0, 1, len(grupos)))  # Crea una paleta de colores matemáticamente espaciada
        mapa = {g: colores[i] for i, g in enumerate(grupos)} # Asigna color a grupo.
        plt.figure(figsize=(9, 5))
        plt.scatter(df[col_x], df[col_y], c=[mapa[g] for g in df[col_grupo]], alpha=0.6)   # Dibuja los puntos asignando el color según el mapa.
        for k, v in mapa.items(): plt.scatter([], [], c=[v], label=k)                    # Truco para la leyenda: Dibuja puntos invisibles para etiquetarlos.
        plt.title(f"{col_x} vs {col_y} (según {col_grupo})", fontsize=14, fontweight='bold')
        plt.legend(title=col_grupo); plt.tight_layout(); plt.show()

    elif estilo == 4 and col_y:                                                      # Boxplot
        orden = sorted(df[col_x].unique().astype(str))         # Ordena las categorías del eje X alfabéticamente.
        datos = [df.loc[df[col_x].astype(str)==c, col_y].values for c in orden]         # Crea una lista de arrays, uno por cada categoría.
        plt.figure(figsize=(10, 6))
        plt.boxplot(datos, labels=orden, showmeans=True, notch=True, patch_artist=True,   # Boxplot calcula: Mediana (línea central), Cuartiles 25% y 75% (caja), y Bigotes (1.5 * IQR).
                    boxprops=dict(facecolor="white", color="#333"))
        
        # Jitter (Ruido): Agrega puntos dispersos aleatoriamente sobre el eje X para mostrar densidad.
        # np.random.normal(i, 0.04): Centrado en la categoría 'i' con desviación 0.04.
        for i, d in enumerate(datos, start=1):
            x = np.random.normal(i, 0.04, size=len(d))
            plt.plot(x, d, 'o', alpha=0.2, color="#55a868", markersize=4)
            
        plt.title(f"{col_y} por {col_x}", fontsize=14, fontweight='bold')
        plt.grid(axis='y', alpha=0.3); plt.tight_layout(); plt.show()
 elif estilo == 5 and col_y:                                                   # --- ESTILO 5: BARRAS (Comparación de Medias) ---
        data_agg = df.groupby(col_x)[col_y].mean().sort_index()                          # Agregación: Agrupa por X y calcula el Promedio (mean) de Y.
        plt.figure(figsize=(10, 5))
        ax = data_agg.plot(kind='bar', color="#c44e52", alpha=0.9, edgecolor='black')
        plt.title(f"Promedio de {col_y} según {col_x}", fontsize=14, fontweight='bold')
        plt.ylabel(f"Promedio de {col_y}"); plt.xticks(rotation=45)
        
        if "probabilidad" in col_y or "imagen" in col_y:                                   # Formato Porcentaje: Si detecta probabilidad, multiplica por 100 y pone %.
            ax.yaxis.set_major_formatter(mtick.PercentFormatter(100 if data_agg.max()>1 else 1.0, decimals=0))
        plt.grid(axis='y', linestyle='--'); plt.tight_layout(); plt.show()

    elif estilo == 6 and col_y:                                                        # --- ESTILO 6: LÍNEAS (Tendencias) ---
        data_agg = df.groupby(col_x)[col_y].mean().sort_index()                                    # Agregación por promedio.
        plt.figure(figsize=(10, 5))
        ax = data_agg.plot(kind='line', marker='o', linewidth=3, color="#8172b3")
        plt.title(f"Tendencia: {col_y} al variar {col_x}", fontsize=14, fontweight='bold')
        plt.ylabel(col_y); plt.grid(True, linestyle='--', alpha=0.5); plt.tight_layout(); plt.show()

# Ejecucucion
if __name__ == "__main__":                                                             # Garantiza que el código SOLO se ejecuta si corrés el archivo directamente (no si lo importás).
    ARCHIVO = "simulated_tracking.csv"                                                           # Definir nombre del archivo (Cambiar si usás otro CSV).
    
    try:                                                                               #Inicia bloque
        print("¡HOLA GRUPO! Estoy procesando datos del CSV...")
        
        # 1. CARGA
        df_raw = pd.read_csv(ARCHIVO)     # Lee CSV del disco y llamamos a TODAS las funciones
        df_clean = preparar_base(df_raw)  # Limpia nombres y nulos.
        df_full = imputar_datos(df_clean) # Rellena datos faltantes con IA.
        df_full = unificar_sexo(df_full)  # Arregla dummies de sexo.
        
        # 2. SELECCIÓN DE OBJETIVO (A QUIÉN QUEREMOS PREDECIR)  # filtra columnas que sean de voto actual.
        cols_voto = [c for c in df_full.columns if "voto_" in c and "anterior" not in c] # agarra todas las columnas de voto actual (voto_a, voto_b, voto_c, etc.). Descarta las de voto anterior.
        col_target = listar_y_elegir(cols_voto, "¿A quien queres trackear?") # Muestra menú interactivo y el usuario elige qué candidato quiere modelar.

        # 3. MODELADO LOGÍSTICO (REGRESIÓN)
        ### fecha → no predice
        ### encuesta (ID) → ruido
        ### el propio col_target → escaparía fuga de datos
        ### otros "voto" actuales → también fuga de datos.
        
        excluir = ["fecha","encuesta",col_target] + [c for c in df_full.columns if "voto_" in c and c!=col_target]  ## definimos las variables que queremos excluir de para graficar. X (predictoria) e Y (objetivo)
        X = df_full.drop(columns=excluir, errors='ignore')  # indepdencia necesaria para elegir que variables predecir       # Excluimos 'fecha' y 'encuesta' (no predicen) y el propio voto para no hacer trampa.
        Y = df_full[col_target]                                                                                      ## pero las agregamos aca. 
        
        # 3.2 Entrenamos el modelo logístico. # es la Instancia del modelo "Logit". max_iter=1000 evita problemas de convergencia.
        model = LogisticRegression(max_iter=1000)     # Ecuación: P(Voto) = 1 / (1 + e^-(B0 + B1*Edad + B2*Estrato...))
        model.fit(X, Y)                                ## Ajusta la regresión logística usando todas las filas completas.
        
        
        df_full["probabilidad_voto"] = model.predict_proba(X)[:, 1] * 100   ## # Creamos la variable 'Probabilidad de Voto' (0 a 100) para usar en gráficos.  #aplica la sigmoide #convierte probabilidad a porcentaje
        

        # Extraemos los Coeficientes (Betas) de la regresión. # coeficiente positivo: Aumenta chance de voto. # negativo: Disminuye.
        coefs = pd.DataFrame({"Variable": X.columns, "Peso": model.coef_[0]})   ## extrae los coeficientes, es decir las BETAS (b0 b1, ...) cada columna X elegida.... dentro del DF para ponerlo dentro de "coefs"
        coefs["Impacto_Absoluto"] = coefs["Peso"].abs() #                        # vamos a medir el impacto absoluto de cada coefs y los valores absolutos de su PESO en la variable elegida
        top_5 = coefs.sort_values("Impacto_Absoluto", ascending=False).head(5)    # mostramos los primeros 5 #ordena con sort.values() dentro de "top_5"
        
        print(f"\n Los cinco coeficientes que mas influyen: {col_target.upper()}")
        print(top_5[["Variable", "Peso"]].to_string(index=False))
        print("------------------------------------------------------------------\n")

        # Elegir tracking tempral (rolling window mean())
        print("\n GENERANDO TRACKING TEMPORAL...")
        
        # 1. Preparamos los datos: copiamos solo lo necesario
        df_track = df_full[["fecha", "encuesta", col_target]].copy()
   # 2. Aseguramos que la fecha sea cronológica (Matemática: Ordenamiento Temporal)
        df_track["fecha"] = pd.to_datetime(df_track["fecha"], format="mixed", dayfirst=False)
        df_track = df_track.set_index("fecha").sort_index()
        
        # 3. Menú para elegir la ventana (El "N" del promedio)
        ventana_str = listar_y_elegir(["Semanal (7D)", "Mensual (30D)", "Trimestral (90D)"], "Elegí ventana de suavizado")
        ventana = "90D" if "90" in ventana_str else "30D" if "30" in ventana_str else "7D"
        
        # 4. Cálculo Matemático: Media Móvil Simple (SMA)
        # Formula: Promedio de los puntos entre (t) y (t - ventana)
        df_track["media_movil"] = df_track[col_target].rolling(ventana).mean()
        
        # 5. Gráfico
        plt.figure(figsize=(10, 5))
        ax = df_track["media_movil"].plot(linewidth=2.5, color="#d62728")
        ax.yaxis.set_major_formatter(mtick.PercentFormatter(1.0, decimals=0)) # Eje Y en %
        plt.title(f"Evolución Intención de Voto: {col_target.upper()} ({ventana})", fontsize=14)
        plt.grid(True, linestyle="--", alpha=0.5); plt.tight_layout(); plt.show()
        # =============================================================================

