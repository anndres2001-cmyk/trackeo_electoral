import pandas as pd               # manejo de Tablas (DataFrames). Matemáticamente son Matrices.
import numpy as np                # cálculo numérico, maneja vectores y matrices rápidas.
import matplotlib.pyplot as plt   # librería base para graficar (Ejes, Figuras).
import matplotlib.ticker as mtick # herramienta para formatear ejes (ej: poner el signo %).
import os                         # "Operating System". Permite crear carpetas y guardar archivos en tu PC.

# Librerías de Inteligencia Artificial (Scikit-Learn)
from sklearn.experimental import enable_iterative_imputer  # Habilita el MICE (aún es experimental en sklearn).
from sklearn.impute import IterativeImputer                # El algoritmo MICE para llenar datos faltantes.
from sklearn.linear_model import LinearRegression          # Usado por MICE para adivinar números.
from sklearn.linear_model import LogisticRegression        # Usado para predecir Voto (Sí/No).

### SELECCIONAR CANDIDATO

def listar_y_elegir(lista_opciones, mensaje="Seleccioná una opción"): #de forma numerica elegimos al candidato a traves de la funcion "listar_y_elegir". recibe una lista de opciones y un mensaje opcional que se muestra como título del menú.
    print(f"\n--- {mensaje} ---")                  # Imprime el título del menú.
    for i, op in enumerate(lista_opciones):       # Recorre la "lista_opciones" con enumarate(), indexando el conjunto de opciones (0, 1, 2...).
        if isinstance(op, tuple):                 # wi la opción es una tupla
            print(f"[{i}] {op[0]}")               # ... muestra solo el primer nombre.
        else:
            print(f"[{i}] {op}")                  # sino, muestra la opción tal cual.
    
    while True:                                   # bucle infinito: no sale hasta que el usuario escriba bien (return)
        try:
            inp = input("Ingrese el número: ")    # pide el dato al teclado.
            idx = int(inp)                        # Intenta convertir ese string a numero entero
            
            # Lógica Booleana: Verifica si el número está dentro del rango de la lista.
            if 0 <= idx < len(lista_opciones):    #el indice dentro de a logica
                val = lista_opciones[idx]         # recuperando el objeto real de la lista.
                return val[0] if isinstance(val, tuple) else val # Devuelve el valor limpio.
            
            print("EROR.")      # Si el número es muy alto o negativo.
        except ValueError:
            print("ERROR. Escribime un numero válido.") # Si escribió letras en vez de números.

# LIMPIEZA
def preparar_base(df_raw): #vamos a usar el CSV como base cruda #vamos a normalizar los nombres de las columnas #eliminamos filas que no sirvan (sin fecha o voto)
    df = df_raw.copy() # creamos una copia en memoria para no romper el original df_raw.copy()
    df.columns = (df.columns.str.strip().str.lower() # .str.strip(): Saca espacios a los costados. # .str.lower(): Pasa todo a minúsculas.
                  .str.replace(r"[^a-z0-9_ ]", "", regex=True)
                  .str.replace(r"\s+", "_", regex=True)) # eeemplaza espacios internos por guion bajo. # regex r"[^a-z0-9_ ]": "Si NO es letra, número o guion bajo, bórralo".
    
    cols = df.columns                                     # Guarda la lista de nombres limpios.
    print("\nDIAGNÓSTICO DE COLUMNAS")

    try:                                                                                                   # con "try" niciamos un bloque que atrapará errores si falta alguna columna.
        c_fecha = [c for c in cols if "fecha" in c or "date" in c or "time" in c][0]                       # busca columna que tenga "fecha", "date" o "time". Toma la primera [0].
        c_id = [c for c in cols if ("ident" in c or "id_" in c or "encuesta" in c) and "fecha" not in c][0] # usca ID: debe decir "id" o "encuesta" PERO NO "fecha" (Lógica: A y No B).
        c_estrato_list = [c for c in cols if "estrato" in c or "socio" in c]                                # busca Estrato: puede no existir, por eso chequeamos si la lista está vacía al final.
        c_estrato = c_estrato_list[0] if c_estrato_list else None                                           # busca posibles columnas de estrato; puede haber 0 o más.
        c_sexo = [c for c in cols if "sexo" in c or "genero" in c][0]                                         
        c_edad = [c for c in cols if "edad" in c or "anos" in c][0]
        c_educ = [c for c in cols if "educ" in c or "nivel" in c or "instruccion" in c][0]
        c_hogar = [c for c in cols if "integrantes" in c or "hogar" in c or "personas" in c][0]
        c_imagen = [c for c in cols if "imagen" in c][0]
        c_voto = [c for c in cols if "voto" in c and "anterior" not in c][0]                                  # en caso de voto elegimos que no sea "anterior"
        c_voto_ant = [c for c in cols if "anterior" in c][0]

        col_map = {                                                                                            #a las busquedas de nombres las pusimos dentro de un diccionario para poder integrarlas mejor y cambiarles el nombre
            c_fecha: "fecha", c_id: "encuesta", c_sexo: "sexo", c_edad: "edad",
            c_educ: "nivel_educativo", c_hogar: "integrantes_h", c_imagen: "imagen_candidato",
            c_voto: "voto", c_voto_ant: "voto_anterior"
        }
        if c_estrato: col_map[c_estrato] = "estrato" #solo renombra estrato si existe.

        print(f"Columnas identificadas")
    except IndexError:                                                                                         # Si alguna lista [c for c...] quedó vacía, [0] significa que da ERROR, por lo tanto, que imprima error
        raise ValueError("ERROR: faltan columnas obligatorias en el CSV.")

    df = df.rename(columns=col_map) # aplica los renombres definidos en col_map. ACA SE ESTANDARIZAN las variables para el resto del pipeline.
vars_txt = ["estrato", "sexo", "nivel_educativo", "voto", "voto_anterior"]                                  ## UNA VEZ las columnas esten limpias hay que limpiarlas, a las variables (string) cualuqier cosa reemplazamos por np.nan
    for col in vars_txt:                                                                                        ## Recorremos una por una todas esas columnas.
        if col in df.columns:                                                                                    ## verificamos que la columna exista realmente en el DataFrame.
            df[col] = df[col].astype(str).str.strip().str.lower().replace(["nan", "none", "null", "", " "], np.nan) ##las estandariza y al resto las vuelve NaN

    vars_num = ["edad", "integrantes_h", "imagen_candidato"]                                                      ## a las Variables numérica las forzamos a número. 'errors="coerce"' convierte errores en NaN (Vacío).
    for col in vars_num:                                                                                         ## Lista de columnas numéricas que pueden venir mal cargadas.
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    criticas = ["fecha", "encuesta", "integrantes_h", "imagen_candidato", "voto", "voto_anterior"]              # # Si falta fecha, voto o imagen, la encuesta no sirve. Se elimina la fila.
    criticas_reales = [c for c in criticas if c in df.columns]                                                  # Filtramos solo las que existen en "criticas" a "critical_reales"
    
    n_antes = len(df)                                                                                           ## guardamos las filas en una variable n_antes , antes de eliminarlas
    df = df.dropna(subset=criticas_reales)                                                                       # Drop NaN (Borrar Nulos). Elimina filas inservibles: sin fecha, sin voto, sin imagen, etc.
    print(f"Se eliminaron {n_antes - len(df)} filas por falta de datos")

    if "imagen_candidato" in df.columns: df["imagen_candidato"] = df["imagen_candidato"].clip(0, 100)            # si la imagen del candidato existe entonces las ajustamos a 0 o 100 si pasa alguna de las dos. Función Clip. f(x) = min(max(x, 0), 100).
    
    return df
def unificar_sexo(df):                                                                                          ## vamos a detectar las columnas de sexo y sus derivados: generando sexo_mas_unificado y sexo_fem_unificado
    df_out = df.copy() ## Busca todas las columnas que empiecen con 'sexo_'
    cols_sexo = [c for c in df_out.columns if c.startswith("sexo_")]                                       #buscamos todas las columnas que empiecen por sexo
    cols_fem = [c for c in cols_sexo if "fem" in c or "mujer" in c or c.endswith("_f")]                   #filtramos por palabras claves entre los "sexo"
    cols_masc = [c for c in cols_sexo if "masc" in c or "hombre" in c or c.endswith("_m")]

    if cols_fem:
        df_out["sexo_femenino_unificado"] = df_out[cols_fem].sum(axis=1).clip(0, 1)                 #si tenía sexo_fem=1 y sexo_mujer=0 → 1. si tenía errores tipo 1 y 1 → queda 2 → clip(0,1) lo baja a 1.
        df_out = df_out.drop(columns=cols_fem)                                                      # Borra las originales para no duplicar.
    if cols_masc:
        df_out["sexo_masculino_unificado"] = df_out[cols_masc].sum(axis=1).clip(0, 1)
        df_out = df_out.drop(columns=cols_masc)
    return df_out

def imputar_datos(df_limpio):                                                                       # ahora que tenemos las columnas vamos a IMPUTAR con MICE que utiiliza las relaciones matematicas entre variables para estimar los valores faltantes.
    df = df_limpio.copy()                                                                          ## hacemos una copia del DF
    cols_cat = [c for c in ["estrato", "sexo", "nivel_educativo"] if c in df.columns]               # Elegimos qué variables categóricas vamos a usar para ayudar a la predicción.
    if "voto" in df.columns: df = pd.get_dummies(df, columns=["voto"], dummy_na=False)               ## # BINARIZAMOS "voto" y "voto_anterior"(One-Hot Encoding) para que el modelo 'vea' a quién vota la gente. # y use eso para predecir su estrato/edad faltante.
    if "voto_anterior" in df.columns: df = pd.get_dummies(df, columns=["voto_anterior"], dummy_na=False)

# Binarizamos las demográficas faltantes
    df_encoded = pd.get_dummies(df, columns=cols_cat, dummy_na=False)
    
    # Algoritmo MICE:
    # Itera (repite) regresiones lineales.
    # Primero: rellena con el promedio.
    # Segundo: predice Edad usando (Voto + Estrato). Actualiza Edad.
    # Tercero: predice Estrato usando (Voto + Edad nueva).
    # ... Repite 20 veces (max_iter) hasta que los números se estabilizan (convergen).
    imputer = IterativeImputer(estimator=LinearRegression(), max_iter=20, random_state=42, min_value=0) # creamos el objeto MICE que imputará los valores faltantes usando regresiones lineales iteradas. 
    
    
    cols_si = [c for c in df_encoded.columns if c not in ["fecha", "encuesta"]]    # celeccionamos todas las columnas numéricas excepto los IDs y Fechas (que no tienen correlación matemática útil).
    if cols_si:
        try:    #Abre bloque seguro para ejecutar el imputador sin romper el programa si falla.
            df_encoded[cols_si] = imputer.fit_transform(df_encoded[cols_si])     ## ajusta regresiones internas y rellena todos los valores faltantes. El imputador devuelve una matriz numérica completa y la
            if "edad" in df_encoded.columns: df_encoded["edad"] = df_encoded["edad"].round().astype(int) # Si la columna “edad” existe luego del proceso entonces redondeo: La edad estimada puede ser 34.6 años -> pasamos a 35.
        except: 
            pass # si falla (ej: matriz vacía), devolvemos como estaba.
        
    return df_encoded

# Graficos

def graficar_estilo_premium(df, col_x, col_y=None, col_grupo=None, estilo=1):    # ahora GRAFICOS usando matplotlib. DF: tabla de graficos. col x/ col_y
    plt.style.use('seaborn-v0_8-whitegrid')                                      # configuramos estética (fondo blanco con grilla suave).
    
    if estilo == 1:                                                              # 1- vamos a dar la opcion de elegir el grafico: histograma
        variable = df[col_x]
        plt.figure(figsize=(8, 5))
        plt.hist(variable, bins=20, edgecolor="black", color="#69b3a2", alpha=0.8) # bins= divide el rango de datos en 20 cajones
        plt.title(f"Distribución de {col_x}", fontsize=14, fontweight='bold')
        plt.ylabel("Cantidad de Casos"); plt.xlabel(col_x)
        plt.tight_layout(); plt.show()

    elif estilo == 2 and col_y:                                                 # 2- scatter
        plt.figure(figsize=(8, 5))
        plt.scatter(df[col_x], df[col_y], alpha=0.5, color="#4c72b0")          # Plotea puntos (x, y) en el plano cartesiano.
        plt.title(f"Correlación: {col_x} vs {col_y}", fontsize=14, fontweight='bold')
        plt.xlabel(col_x); plt.ylabel(col_y)
        plt.tight_layout(); plt.show()

